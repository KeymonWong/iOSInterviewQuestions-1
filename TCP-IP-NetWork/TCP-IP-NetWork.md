# HTTP&HTTPS的发展历程

HTTP -- HyperText Transfer protocol 超文本传输协议

1990年HTTP诞生，在全球信息刚刚起步的时候就得到了应用。
1991年产生了0.9版本，只有一个get命令
1996年产生了http1.0版本，文字、图像、视频、二进制文件。
1999年 http1.1版本，就是目前流行的版本
2000年产生了https 以安全为目标的http通道。


# 可靠的TCP连接为何是三次握手

## 首先，咱们先来熟悉下经典的tcp/ip模型。

![](https://user-gold-cdn.xitu.io/2018/6/12/163efbd9d32322bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

tcp/ip 模型为了方便使用，将osi七层模型划分成了四层，分别为网络接口层，网络层，传输层，应用层。
他们作用分别为：
1）网络接口层：主要作用是将ip地址和计算机的物理地址互相绑定，并实现二进制流和计算机硬件的高低电位的转换。
2）网络层：主要作用是通过ip地址将两台物理机链接起来，实现ip数据包的传输；
3）传输层：使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）；
4）应用层：负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是HTTP、FTP等。

## 今天咱们主要来看下tcp模型中主要的tcp协议

计算机通信中，要想实现可靠的网络通信，tcp协议是必不可少的一环。那么tcp协议是如何实现可靠通信的呢？这就首先要从经典的三次握手谈起。

三次握手即客户端与服务器至少(网络超时的话会多于三个)要发送三个数据包来建立tcp连接。

![](https://user-gold-cdn.xitu.io/2018/6/12/163efe8722b21aa7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第一次握手：客户端发送建立连接数据包，发送之后状态变成SYN_SENT，数据包内容里面SYN标志位为1以及一个随机的序列号seq，假设值为j。
第二次握手：服务器收到请求之后，发送数据包给客户端，服务器状态变为SYN_RECV,数据包内容包含标志位SYN和ACK，值都为1。确认序列号ack值为j+1，随机序列号seq，假设值为i。
第三次握手：客户端收到服务端的数据包，验证ACK和SYN为1后，发送一个确认数据包，客户端进入ESTABLISHED状态，数据包包括标志位ACK，值为1。确认序列号ack，值为i+1。序列号seq，值为j+1.

补充说明下：确认序列号ack表示的是下一次收到的包的seq，接收方通过seq和len来确认数据包是否有效，是丢弃数据包，还是放入正常数据包序列或者是放入失序数据包序列。

## 那么下面咱们来看下为啥tcp是三次握手，不是两次，一次或者四次。
第一次握手：
a发送一个数据包给b。如果只握一次手，就建立连接，显然是不可能的，a连b的真实性都不知道。
第二次握手：
b收到连接请求后，发送确认建立连接请求。如果两次握手就成功建立连接的话会出现一个问题：
a给b发送了一个请求连接包，由于网络原因，过了很久之后b才收到这个包，b收到之后，向a返回一个数据包。这个时候由于时间超时，a会丢掉这个数据包。如果是两次握手的话，这时候b状态为成功建立连接，会一直等待a传输数据。这样会导致服务器资源浪费。
第三次握手：
a收到b的确认连接请求后，验证数据正确后，再向a发送一个确认请求，b收到后验证数据是否正确。正确后即连接建立成功。

三次握手可以很好的避免网络超时导致的丢包情况，服务器和客户端都要分别收到正确的ACK之后才能表示连接建立，如果未收到，就会启用超时重传机制。当然如果网络确实比较差，导致连接无法建立，也不可能一直重传。操作系统中会有设置重传次数这个字段，以避免无效重转。

为啥不四次握手：
最开始本来是四次握手，四次握手的情形是服务器发送的SYN和ACK是分开发送的，所以是四次，后面给进行了优化，所以就成为了三次握手。

## 挥手
当客户端和服务器通过三次握手建立了TCP连接以后，就可以进行数据通信了，通信完毕后，双方就可以断开连接了，断开连接就会涉及到咱们的四次挥手了。下面咱们来简单看下tcp的四次挥手。

![](https://user-gold-cdn.xitu.io/2018/6/12/163f01440e63a1ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第一次挥手：
client发送一个标志位FIN为1和一个seq为m的数据包；
第二次挥手：
server收到了client发送的FIN报文段，向client回一个ACK报文段，ack值为m+1，server告诉client，我“同意”你的关闭请求，这个时候client不能在发送数据，server不能再接收数据，server还能给client发送数据；
第三次挥手：
server向client发送FIN报文段，请求关闭连接，同时server进入LAST_ACK状态；
第四次挥手：
client收到server发送的FIN报文段，向server发送ACK报文段，然后client进入TIME_WAIT状态；server收到client的报文段以后，就关闭连接；此时，client等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，client也可以关闭连接了。

至于为啥是四次挥手，本质的原因是咱们的tcp连接是全双工的，在两个方向都需要关闭，所以两个方向都需要发送一个关闭请求和确认请求。

(MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。
TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。)


## 下面介绍下tcp可靠的一个重要机制，超时重传
超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。三次握手，正常的数据传输，以及四次握手过程中只要出现超时情况，都会触发重传。
那么tcp是如何界定超时的呢，这时候又引出两个新东西。一个是RTT,另外个是RTO。感兴趣的同学可以下去了解，这里就不再详细介绍了。
总结：tcp协议是一个很复杂的协议，本篇文章由于篇幅原因只是简单的介绍了其中很小一个知识点，并没有很深层次的介绍tcp，如有更多疑惑，欢迎留言讨论。
